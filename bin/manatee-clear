#!/usr/bin/env node
// -*- mode: js -*-
// recover a manatee shard in error

var exec = require('child_process').exec;
var path = require('path');
var util = require('util');

var assert = require('assert-plus');
var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var manatee = require('./manatee_common');
var pg = require('pg');
var vasync = require('vasync');
var verror = require('verror');
var zkplus = require('zkplus');

var LOG = bunyan.createLogger({
        name: path.basename(process.argv[1]),
        level: (process.env.LOG_LEVEL || 'info'),
        src: true,
        serializers: {
                err: bunyan.stdSerializers.err
        }
});

var parseOptions = function() {
        var option;
        var opts = {};
        var parser = new getopt.BasicParser('hv', process.argv);

        while((option = parser.getopt()) !== undefined) {
                switch (option.option) {
                case 'h':
                        usage();
                        break;
                case 'v':
                        LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                        if (LOG.level() <= bunyan.DEBUG)
                                LOG = LOG.child({src: true});
                        break;
                default:
                        usage('invalid option: ' + option.option);
                        process.exit(1);
                        break;
                }
        }

        if (parser.optind() >= process.argv.length) {
                usage('missing required argument: "shard_id"');
        }

        if (parser.optind() + 1 >= process.argv.length) {
                usage('missing required argument: "my_ip"');
        }

        if (parser.optind() + 2 >= process.argv.length) {
                usage('missing required argument: "zookeeper_ip"');
        }

        opts.shardId = process.argv[parser.optind()];
        opts.myIp = process.argv[parser.optind() + 1];
        opts.zookeeperIp = process.argv[parser.optind() + 2];

        return opts;
};

var usage = function(msg) {
        if (msg) {
                console.error(msg);
        }

        var str = 'clears the manatee shard out of error state';
        str += '\nusage: ' + path.basename(process.argv[1]);
        str += ' shard_id my_ip zookeeper_ip';
        str += '\nexample: ./manatee_clear 1.moray.joyent.us 10.99.99.32 ' +
               '10.99.99.13';
        console.error(str);
        process.exit(msg ? 1 : 0);
};

var cleanupManatee = function(shardId, myIp, zookeeperIp, callback) {
        LOG.debug({
                shardId: shardId,
                myIp: myIp,
                zookeeperIp: zookeeperIp
        }, 'entering cleanupManatee');

        var tasks = [
                // look up in zookeeper to see who was the primary
                function createZkClient(arg, cb) {
                        var zkLog = LOG.child({
                                component: 'zookeeper',
                                level: LOG.level
                        });
                        manatee.createZkClient({log: zkLog, zk: zookeeperIp},
                                               function (err, zk)
                        {
                                arg.zk = zk;
                                return cb(err);
                        });
                },
                function isPrimary(arg, cb) {
                        manatee.loadTopology(arg.zk, function (err, topology) {
                                if (err) {
                                        return cb(err);
                                }

                                arg.myShard = topology[shardId];
                                LOG.debug({topology: topology}, 'got topology');
                                if (!arg.myShard.error) {
                                        return cb(new verror.VError(
                                                'shard is not in error state'));
                                }

                                arg.isPrimary =
                                        (myIp === arg.myShard.error.primary);
                                return cb();
                        });

                        return (undefined);
                },
                // if primary delete error node
                function deleteErrorNode(arg, cb) {
                        if (!arg.isPrimary) {
                                LOG.debug('not primary');
                                return cb();
                        }
                        var path_ = '/manatee/' + shardId + '/error';
                        LOG.info({
                                path: path_
                        }, 'removing error node');
                        arg.zk.rmr(path_, cb);
                        return (undefined);
                },
                // restart manatee
                function restartPrimarySitter(arg, cb) {
                        if (!arg.isPrimary) {
                                LOG.debug('not primary');
                                return cb();
                        }
                        var cmd = 'svcadm disable manatee-sitter; ' +
                              'svcadm enable manatee-sitter';
                        LOG.info({cmd: cmd}, 'restarting manatee-sitter');

                        exec(cmd, cb);
                        return (undefined);
                },
                // if not primary, watch for error node to go away
                function watchErrorNode(arg, cb) {
                        if (arg.isPrimary) {
                                LOG.debug('not standby');
                                return cb();
                        }
                        LOG.info('waiting for error node to be removed by ' +
                                 'primary');
                        arg.zk.watch('/manatee/' + shardId + '/error',
                                 function(err, listener)
                        {
                                if (err) {
                                        return cb(err);
                                }
                                listener.once('delete', function() {
                                        LOG.info('error node deleted');
                                        return cb();
                                });
                                return (undefined);
                        });
                        return (undefined);
                },
                // watch election, if there's a node under the path, then the
                // primary has started, so it's safe to restart standby
                function watchElection(arg, cb) {
                        if (arg.isPrimary) {
                                LOG.debug('not standby');
                                return cb();
                        }
                        LOG.info('waiting for primary to come online');
                        arg.zk.watch('/manatee/' + shardId + '/election',
                                 { method: 'list' }, function(err, listener) {

                                listener.on('children', function(children) {
                                        LOG.info({
                                                nodes: children
                                        }, 'primary online');
                                        return cb();
                                });
                        });
                        return (undefined);
                },
                // restart manatee
                function restartStdbySitter(arg, cb) {
                        if (arg.isPrimary) {
                                LOG.debug('not standby');
                                return cb();
                        }
                        var cmd = 'svcadm disable manatee-sitter; ' +
                              'svcadm enable manatee-sitter';
                        LOG.info({cmd: cmd}, 'restarting manatee-sitter');
                        exec(cmd, cb);
                        return (undefined);
                }
        ];

        vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
                LOG.debug({err: err}, 'finished cleanupManatee');
                return callback(err);
        });
};

var _opts = parseOptions();

cleanupManatee(_opts.shardId, _opts.myIp, _opts.zookeeperIp, function(err) {
        if (err) {
                LOG.fatal({err: err}, 'unable to cleanup manatee');
        }
        process.exit(err);
});
